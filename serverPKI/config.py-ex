"""
Copyright (C) 2015-2020  Axel Rau <axel.rau@chaos1.de>

This file is part of serverPKI.

serverPKI is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Foobar is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with serverPKI.  If not, see <http://www.gnu.org/licenses/>.
"""


# Module to make config settings available to members of package

import io, sys, syslog
from typing import Tuple
import configobj, validate

##from serverPKI.utils import sld, sli, sle
from serverPKI.cli_options import options
def sld(msg):
    print(msg)

def sli(msg):
    print(msg)

def sle(msg):
    print(msg)

# -------------- config spec -------------

configspec = """
[Pathes]

    # this path should be customized:
    home = string()

    # some flat files not in RDBMS
    db = string()

    # local CA cert
    ca_cert = string()
    ca_key = string()

    # encryption of keys in db
    db_encryption_key = string()

    # lets encrypt
    le_account = string()

    work = string()
    work_tlsa = string()

    # DNS server for maintaining TLSA RR (empty = on local host)
    tlsa_dns_master = string()



    # Used for maintenance of TLSA RR and ACME challenges by zone file
    # editing (historical)
    # required convention = zone_file_root/example.com/example.com.zone

    zone_file_root = string()

    # key for rndc command
    dns_key = string()

    # mode + owner of *.tlsa and acme_challenges.inc files in zone directory
    # in octal notation
    zone_tlsa_inc_mode = string(default='0660')

    # owner and group of files. included by zone files
    zone_tlsa_inc_uid =   integer(default=53)
    zone_tlsa_inc_gid = integer()

    # filename for challenges to be included by zone file:
    zone_file_include_name = string()

    # location of key for signing dynamic DNS commands
    ddns_key_file = string()


# Defaults of local X509 certificate standard attributes
[X509atts]

    lifetime = integer()
    bits = integer()

    # Definition of fixed X.509 cert attributes
    [[names]]

        C = string(min=2,max=2)
        L = string()
        O = string()-RAU
        CN = string()

    [[extensions]]


[DBAccount]

    dbHost =         string()
    dbPort =         integer(min=1,max=64000)
    dbUser =         string()
    dbDbaUser =      string()
    dbSslRequired =  boolean()

    dbDatabase =     string()
    dbSearchPath =   list()
    dbCert =         string()
    dbCertKey =      string()

[misc]

    SSH_CLIENT_USER_NAME = string()

    LE_SERVER = string()

    # e-mail for registration
    LE_EMAIL = string()

    # zone update method for challenge ('ddns' or 'zone_file')
    LE_ZONE_UPDATE_METHOD = option('ddns', 'zone_file')

    # Key size and lifetime of local CA cert
    LOCAL_CA_BITS = integer(min=3096,max=4096)
    LOCAL_CA_LIFETIME = integer(min=365)

    # subjects in table Subjects for CA certs
    # to be changed only before creating DB
    SUBJECT_LOCAL_CA = string()
    SUBJECT_LE_CA = string()

    # number of days to publish new certs before deploying it
    PRE_PUBLISH_TIMEDELTA = integer(min=7)

    # number of days to send remainder before expiration of local certs
    LOCAL_ISSUE_MAIL_TIMEDELTA = integer(min=1)

    # details for sending reminder mails
    MAIL_RELAY = string()
    MAIL_SUBJECT = string()
    MAIL_SENDER = string()
    MAIL_RECIPIENT = list()

    SYSLOG_FACILITY = string()
"""


# ------------------ configuration file parsing ---------------

# container Classes, filled by parse_config

class Pathes(object):
    pass

class X509atts(object):
    pass

class DBAccounts(object):
    pass

class Misc(object):
    SYSLOG_FACILITY = syslog.LOG_LOCAL6

def parse_config(test_config_file=None):
    """
    Parse config file. Exits on error.
    :param test_config_file: config file path for tesing
    :return:
    """
    global Pathes, X509atts, DBAccounts, Misc

    def dict_to_class(the_class: str, section: str, list: Tuple):
        """
        Set class attributes from parsed config data
        :param the_class: Name of class
        :param section: Name of config section
        :param list: list of section keywords
        :return:
        """
        for item in list:
            setattr(globals()[the_class], item, config[section][item])


    the_config_spec = configobj.ConfigObj(io.StringIO(initial_value=configspec, newline='\n'),
                                                      _inspec=True,
                                                      encoding='UTF8')

    config = None
    for config_file in (test_config_file,
                        options.config_file,
                        sys.prefix + '/etc/serverpki.conf',
                        '/usr/local/etc/serverPKI/serverpki.conf'):
            if not config_file:
                continue
            sld('Trying config file {}'.format(config_file))
            if not os.path.isfile(config_file):
                continue
            sli('Using config file {}'.format(config_file))
            try:
                config = configobj.ConfigObj(config_file,
                                             encoding='UTF8',
                                             interpolation='Template',
                                             configspec=the_config_spec)
            except SyntaxError as e:
                sle('Configuration file errors found. Can''t continue. List of errors:')
                for err in e.errors:
                    sle('{}'.format(err))
                sys.exit(1)
            break
    if not config:
        sle('No config file found. Can''t continue.')
        sys.exit(1)

    vtor = validate.Validator()
    result = config.validate(vtor, preserve_errors=True)
    if result != True:
        sle('Config validation failed:')
        for entry in configobj.flatten_errors(config, result):
            # each entry is a tuple
            section_list, key, error = entry
            if key is not None:
                section_list.append(key)
            else:
                section_list.append('[missing section]')
            section_string = ', '.join(section_list)
            if error == False:
                error = 'Missing value or section.'
            sle(section_string + ' = ' + str(error))

        for sections, name in configobj.get_extra_values(config):

            # this code gets the extra values themselves
            the_section = config
            for section in sections:
                the_section = the_section[section]

            # the_value may be a section or a value
            the_value = the_section[name]

            section_or_value = 'value'
            if isinstance(the_value, dict):
                # Sections are subclasses of dict
                section_or_value = 'section'

            section_string = ', '.join(sections) or "top level"
            print('Extra entry in section: %s. Entry %r is a %s' % (
                                    section_string, name, section_or_value))

        sld(str(result))


    def test_walk(section, key):
        print('[{}] {} = {}'.format(section, key, section[key]))

    config.walk(test_walk)

    exit(1)

    dict_to_class('DBAccounts', 'Database accounts', ('dbHost',
                                                      'dbPort',
                                                      'dbUser',
                                                      'dbDbaUser',
                                                      'dbSslRequired',
                                                      'dbDatabase',
                                                      'dbSearchPath',
                                                      'dbCert',
                                                      'dbCertKey'))


    sli(DBAccounts.dbHost + ' ' + str(DBAccounts.dbPort) + ' ' + DBAccounts.dbUser)


    sys.exit(1)

